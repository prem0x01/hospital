// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: appointments.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountAppointments = `-- name: CountAppointments :one
SELECT COUNT(*) FROM appointments
`

func (q *Queries) CountAppointments(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountAppointments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAppointmentsByStatus = `-- name: CountAppointmentsByStatus :one
SELECT COUNT(*) FROM appointments WHERE status = $1
`

func (q *Queries) CountAppointmentsByStatus(ctx context.Context, status *string) (int64, error) {
	row := q.db.QueryRow(ctx, CountAppointmentsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (patient_id, doctor_id, appointment_date, notes, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, patient_id, doctor_id, appointment_date, status, notes,
          diagnosis, treatment_plan, created_by, created_at, updated_at
`

type CreateAppointmentParams struct {
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Notes           *string          `db:"notes" json:"notes"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, CreateAppointment,
		arg.PatientID,
		arg.DoctorID,
		arg.AppointmentDate,
		arg.Notes,
		arg.CreatedBy,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.AppointmentDate,
		&i.Status,
		&i.Notes,
		&i.Diagnosis,
		&i.TreatmentPlan,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM appointments WHERE id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeleteAppointment, id)
	return err
}

const GetAppointmentByID = `-- name: GetAppointmentByID :one
SELECT
    a.id, a.patient_id, a.doctor_id, a.appointment_date, a.status,
    a.notes, a.diagnosis, a.treatment_plan, a.created_by,
    a.created_at, a.updated_at,
    p.first_name || ' ' || p.last_name as patient_name,
    COALESCE(u.first_name || ' ' || u.last_name, '') as doctor_name
FROM appointments a
JOIN patients p ON a.patient_id = p.id
LEFT JOIN users u ON a.doctor_id = u.id
WHERE a.id = $1
`

type GetAppointmentByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PatientName     interface{}      `db:"patient_name" json:"patient_name"`
	DoctorName      interface{}      `db:"doctor_name" json:"doctor_name"`
}

func (q *Queries) GetAppointmentByID(ctx context.Context, id int32) (*GetAppointmentByIDRow, error) {
	row := q.db.QueryRow(ctx, GetAppointmentByID, id)
	var i GetAppointmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.AppointmentDate,
		&i.Status,
		&i.Notes,
		&i.Diagnosis,
		&i.TreatmentPlan,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PatientName,
		&i.DoctorName,
	)
	return &i, err
}

const GetAppointments = `-- name: GetAppointments :many
SELECT
    a.id, a.patient_id, a.doctor_id, a.appointment_date, a.status,
    a.notes, a.diagnosis, a.treatment_plan, a.created_by,
    a.created_at, a.updated_at,
    p.first_name || ' ' || p.last_name as patient_name,
    COALESCE(u.first_name || ' ' || u.last_name, '') as doctor_name
FROM appointments a
JOIN patients p ON a.patient_id = p.id
LEFT JOIN users u ON a.doctor_id = u.id
ORDER BY a.appointment_date DESC
LIMIT $1 OFFSET $2
`

type GetAppointmentsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetAppointmentsRow struct {
	ID              int32            `db:"id" json:"id"`
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PatientName     interface{}      `db:"patient_name" json:"patient_name"`
	DoctorName      interface{}      `db:"doctor_name" json:"doctor_name"`
}

func (q *Queries) GetAppointments(ctx context.Context, arg GetAppointmentsParams) ([]*GetAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, GetAppointments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAppointmentsRow
	for rows.Next() {
		var i GetAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.AppointmentDate,
			&i.Status,
			&i.Notes,
			&i.Diagnosis,
			&i.TreatmentPlan,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PatientName,
			&i.DoctorName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAppointmentsByDateRange = `-- name: GetAppointmentsByDateRange :many
SELECT
    a.id, a.patient_id, a.doctor_id, a.appointment_date, a.status,
    a.notes, a.diagnosis, a.treatment_plan, a.created_by,
    a.created_at, a.updated_at,
    p.first_name || ' ' || p.last_name as patient_name,
    COALESCE(u.first_name || ' ' || u.last_name, '') as doctor_name
FROM appointments a
JOIN patients p ON a.patient_id = p.id
LEFT JOIN users u ON a.doctor_id = u.id
WHERE a.appointment_date BETWEEN $1 AND $2
ORDER BY a.appointment_date
`

type GetAppointmentsByDateRangeParams struct {
	AppointmentDate   pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	AppointmentDate_2 pgtype.Timestamp `db:"appointment_date_2" json:"appointment_date_2"`
}

type GetAppointmentsByDateRangeRow struct {
	ID              int32            `db:"id" json:"id"`
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PatientName     interface{}      `db:"patient_name" json:"patient_name"`
	DoctorName      interface{}      `db:"doctor_name" json:"doctor_name"`
}

func (q *Queries) GetAppointmentsByDateRange(ctx context.Context, arg GetAppointmentsByDateRangeParams) ([]*GetAppointmentsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, GetAppointmentsByDateRange, arg.AppointmentDate, arg.AppointmentDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAppointmentsByDateRangeRow
	for rows.Next() {
		var i GetAppointmentsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.AppointmentDate,
			&i.Status,
			&i.Notes,
			&i.Diagnosis,
			&i.TreatmentPlan,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PatientName,
			&i.DoctorName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAppointmentsByDoctor = `-- name: GetAppointmentsByDoctor :many
SELECT
    a.id, a.patient_id, a.doctor_id, a.appointment_date, a.status,
    a.notes, a.diagnosis, a.treatment_plan, a.created_by,
    a.created_at, a.updated_at,
    p.first_name || ' ' || p.last_name as patient_name,
    COALESCE(u.first_name || ' ' || u.last_name, '') as doctor_name
FROM appointments a
JOIN patients p ON a.patient_id = p.id
LEFT JOIN users u ON a.doctor_id = u.id
WHERE a.doctor_id = $1
ORDER BY a.appointment_date DESC
LIMIT $2 OFFSET $3
`

type GetAppointmentsByDoctorParams struct {
	DoctorID *int32 `db:"doctor_id" json:"doctor_id"`
	Limit    int32  `db:"limit" json:"limit"`
	Offset   int32  `db:"offset" json:"offset"`
}

type GetAppointmentsByDoctorRow struct {
	ID              int32            `db:"id" json:"id"`
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PatientName     interface{}      `db:"patient_name" json:"patient_name"`
	DoctorName      interface{}      `db:"doctor_name" json:"doctor_name"`
}

func (q *Queries) GetAppointmentsByDoctor(ctx context.Context, arg GetAppointmentsByDoctorParams) ([]*GetAppointmentsByDoctorRow, error) {
	rows, err := q.db.Query(ctx, GetAppointmentsByDoctor, arg.DoctorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAppointmentsByDoctorRow
	for rows.Next() {
		var i GetAppointmentsByDoctorRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.AppointmentDate,
			&i.Status,
			&i.Notes,
			&i.Diagnosis,
			&i.TreatmentPlan,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PatientName,
			&i.DoctorName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPatientAppointments = `-- name: GetPatientAppointments :many
SELECT
    a.id, a.patient_id, a.doctor_id, a.appointment_date, a.status,
    a.notes, a.diagnosis, a.treatment_plan, a.created_by,
    a.created_at, a.updated_at,
    p.first_name || ' ' || p.last_name as patient_name,
    COALESCE(u.first_name || ' ' || u.last_name, '') as doctor_name
FROM appointments a
JOIN patients p ON a.patient_id = p.id
LEFT JOIN users u ON a.doctor_id = u.id
WHERE a.patient_id = $1
ORDER BY a.appointment_date DESC
`

type GetPatientAppointmentsRow struct {
	ID              int32            `db:"id" json:"id"`
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PatientName     interface{}      `db:"patient_name" json:"patient_name"`
	DoctorName      interface{}      `db:"doctor_name" json:"doctor_name"`
}

func (q *Queries) GetPatientAppointments(ctx context.Context, patientID *int32) ([]*GetPatientAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, GetPatientAppointments, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPatientAppointmentsRow
	for rows.Next() {
		var i GetPatientAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.AppointmentDate,
			&i.Status,
			&i.Notes,
			&i.Diagnosis,
			&i.TreatmentPlan,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PatientName,
			&i.DoctorName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTodaysAppointments = `-- name: GetTodaysAppointments :many
SELECT
    a.id, a.patient_id, a.doctor_id, a.appointment_date, a.status,
    a.notes, a.diagnosis, a.treatment_plan, a.created_by,
    a.created_at, a.updated_at,
    p.first_name || ' ' || p.last_name as patient_name,
    COALESCE(u.first_name || ' ' || u.last_name, '') as doctor_name
FROM appointments a
JOIN patients p ON a.patient_id = p.id
LEFT JOIN users u ON a.doctor_id = u.id
WHERE DATE(a.appointment_date) = CURRENT_DATE
ORDER BY a.appointment_date
`

type GetTodaysAppointmentsRow struct {
	ID              int32            `db:"id" json:"id"`
	PatientID       *int32           `db:"patient_id" json:"patient_id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
	CreatedBy       *int32           `db:"created_by" json:"created_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PatientName     interface{}      `db:"patient_name" json:"patient_name"`
	DoctorName      interface{}      `db:"doctor_name" json:"doctor_name"`
}

func (q *Queries) GetTodaysAppointments(ctx context.Context) ([]*GetTodaysAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, GetTodaysAppointments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTodaysAppointmentsRow
	for rows.Next() {
		var i GetTodaysAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.AppointmentDate,
			&i.Status,
			&i.Notes,
			&i.Diagnosis,
			&i.TreatmentPlan,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PatientName,
			&i.DoctorName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAppointment = `-- name: UpdateAppointment :one
UPDATE appointments
SET
    doctor_id = COALESCE($2, doctor_id),
    appointment_date = COALESCE($3, appointment_date),
    status = COALESCE($4, status),
    notes = COALESCE($5, notes),
    diagnosis = COALESCE($6, diagnosis),
    treatment_plan = COALESCE($7, treatment_plan),
    updated_at = NOW()
WHERE id = $1
RETURNING id, patient_id, doctor_id, appointment_date, status, notes,
          diagnosis, treatment_plan, created_by, created_at, updated_at
`

type UpdateAppointmentParams struct {
	ID              int32            `db:"id" json:"id"`
	DoctorID        *int32           `db:"doctor_id" json:"doctor_id"`
	AppointmentDate pgtype.Timestamp `db:"appointment_date" json:"appointment_date"`
	Status          *string          `db:"status" json:"status"`
	Notes           *string          `db:"notes" json:"notes"`
	Diagnosis       *string          `db:"diagnosis" json:"diagnosis"`
	TreatmentPlan   *string          `db:"treatment_plan" json:"treatment_plan"`
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, UpdateAppointment,
		arg.ID,
		arg.DoctorID,
		arg.AppointmentDate,
		arg.Status,
		arg.Notes,
		arg.Diagnosis,
		arg.TreatmentPlan,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.AppointmentDate,
		&i.Status,
		&i.Notes,
		&i.Diagnosis,
		&i.TreatmentPlan,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
